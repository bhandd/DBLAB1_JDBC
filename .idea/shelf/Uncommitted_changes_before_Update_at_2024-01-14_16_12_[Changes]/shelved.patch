Index: src/main/java/dblab1/dblab1_jdbc/model/BooksDb.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * To change this license header, choose License Headers in Project Properties.\r\n * To change this template file, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage dblab1.dblab1_jdbc.model;\r\n\r\nimport dblab1.dblab1_jdbc.model.entityClasses.Book;\r\nimport dblab1.dblab1_jdbc.model.exceptions.BooksDbException;\r\n\r\nimport java.sql.*;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * A mock implementation of the BooksDBInterface interface to demonstrate how to\r\n * use it together with the user interface.\r\n * <p>\r\n * Your implementation must access a real database.\r\n *\r\n * @author anderslm@kth.se\r\n */\r\npublic class BooksDb implements BooksDbInterface {\r\n\r\n    private final List<Book> books;\r\n\r\n    public BooksDb() {\r\n\r\n        books = List.of();\r\n    }\r\n\r\n    @Override\r\n    public boolean connect() throws Exception {\r\n        if (getConnection.StartConnection() != null) {\r\n            System.out.println(\"Yes\");\r\n            return true;\r\n        } else {\r\n            System.out.println(\"No\");\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static Connection shareConnection() {\r\n        try{\r\n            return getConnection.getConnection();\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    @Override\r\n    public void disconnect() throws BooksDbException, SQLException {\r\n        getConnection.EndConnection();\r\n    }\r\n//TODO: sparas ifall den behövs sen.\r\n\r\n    //Added by Anders\r\n//    @Override\r\n//    public List<Book> searchBooksByTitle(String searchTitle)\r\n//            throws BooksDbException {\r\n//        // mock implementation\r\n//        // NB! Your implementation should select the books matching\r\n//        // the search string via a query to a database (not load all books from db)\r\n//        List<Book> result = new ArrayList<>();\r\n//        searchTitle = searchTitle.toLowerCase();\r\n//        for (Book book : books) {\r\n//            if (book.getTitle().toLowerCase().contains(searchTitle)) {\r\n//                result.add(book);\r\n//            }\r\n//        }\r\n//        //spara i books<-SQL-fråga till databas\r\n//      //  result.add(books);\r\n//        return result;\r\n//    }\r\n\r\n\r\n    public static void executeQuery(/*java.sql.Connection con,*/ String query, List<Book> books) throws SQLException {\r\n\r\n      //  Connection con = getConnection.getConnection();\r\n        try (Statement stmt = getConnection.getConnection().createStatement()) {\r\n            // Execute the SQL statement\r\n            ResultSet rs = stmt.executeQuery(query);\r\n\r\n            // Get the attribute names\r\n            ResultSetMetaData metaData = rs.getMetaData();\r\n            int ccount = metaData.getColumnCount();\r\n            for (int c = 1; c <= ccount; c++) {\r\n                System.out.print(metaData.getColumnName(c) + \"\\t\");\r\n            }\r\n            System.out.println();\r\n\r\n            // Get the attribute values\r\n            while (rs.next()) {\r\n\r\n                int bookId = rs.getInt(\"book_id\");\r\n                String ISBN = rs.getString(\"ISBN\");\r\n                String title = rs.getString(\"title\");\r\n/*\r\n                Author author = new Author();\r\n                author.setfName(rs.getString(\"author\"));\r\n*/\r\n                String author = rs.getString(\"fullName\");\r\n                //String author = rs.getString(\"author\");\r\n                Date published = rs.getDate(\"published\");\r\n                //   int pages = rs.getInt(\"pages\");\r\n                //  String language = rs.getString(\"language\");\r\n                String genre = rs.getString(\"genre\");\r\n                int grade = rs.getInt(\"grade\");\r\n                Book book = new Book(bookId, ISBN, title,author, published, genre, grade);\r\n                System.out.println(book.toString());\r\n                books.add(book);\r\n\r\n            }\r\n            System.out.println();\r\n        }\r\n    }\r\n\r\n    public static List<Book> searchDBBook(String query) {\r\n        List<Book> result = new ArrayList<>();\r\n\r\n       // Connection con = getConnection.getConnection();\r\n        try (Statement stmt = getConnection.getConnection().createStatement()) {\r\n            // Execute the SQL statement\r\n            ResultSet rs = stmt.executeQuery(query);\r\n            while (rs.next()) {\r\n                int bookId = rs.getInt(\"book_id\");\r\n                String ISBN = rs.getString(\"ISBN\");\r\n                String title = rs.getString(\"title\");\r\n/*\r\n                Author author = new Author();\r\n                author.setfName(rs.getString(\"author\"));\r\n*/\r\n                String author = rs.getString(\"fullName\");\r\n                //String author = rs.getString(\"author\");\r\n                Date published = rs.getDate(\"published\");\r\n                //   int pages = rs.getInt(\"pages\");\r\n                //  String language = rs.getString(\"language\");\r\n                String genre = rs.getString(\"genre\");\r\n                int grade = rs.getInt(\"grade\");\r\n                Book book = new Book(bookId, ISBN, title,author, published, genre, grade);\r\n                System.out.println(book.toString());\r\n                result.add(book);\r\n                System.out.println(book.toString());\r\n                System.out.println(\"Yes\");\r\n                // } else System.out.println(\"No\");\r\n            }\r\n            rs.close();\r\n        } catch (SQLException e) {\r\n            throw new RuntimeException(e);\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n\r\n\r\n    //TODO: kan användas för att skapa ett objekt för alla variabler och returnera?\r\n    public static int getErrorCount(String query) throws SQLException {\r\nint errorCount = 0;\r\n        try (Statement stmt = getConnection.getConnection().createStatement()) {\r\n            System.out.println(\"current query to execute: \" + query);\r\n            // Execute the SQL statement\r\n\r\n            ResultSet rs = stmt.executeQuery(query);\r\n\r\n            //  Get the attribute names\r\n            ResultSetMetaData metaData = rs.getMetaData();\r\n            int ccount = metaData.getColumnCount();\r\n            for (int c = 1; c <= ccount; c++) {\r\n                System.out.print(metaData.getColumnName(c) + \"\\t\");\r\n            }\r\n            System.out.println();\r\n//TODO: move the while loop in executeQuery, searchBookDB and this one to it´s own method?\r\n            // Get the attribute values\r\n          //  while (rs.next()) {\r\n                //  int bookId = rs.getInt(\"book_id\");\r\n//                String ISBN = rs.getString(\"ISBN\");\r\n//                String title = rs.getString(\"title\");\r\n///*\r\n//                Author author = new Author();\r\n//                author.setfName(rs.getString(\"author\"));\r\n//*/\r\n//                String author = rs.getString(\"Author\");\r\n//                //String author = rs.getString(\"author\");\r\n//                Date published = rs.getDate(\"year\");\r\n//                //   int pages = rs.getInt(\"pages\");\r\n//                //  String language = rs.getString(\"language\");\r\n//                int genre_id = rs.getInt(\"genre_id\");\r\n//                int grade = rs.getInt(\"grade\");\r\n                rs.next();\r\n                errorCount = rs.getInt(\"@@error_count\");\r\n        //    }\r\n            System.out.println(\"executed a query\");\r\n        }catch (SQLException e){\r\n            System.err.println(\"FUCK! Something went to shit again! \"+ e.getMessage());\r\n        }\r\nreturn  errorCount;\r\n    }\r\n\r\n    public static void executeStatement(String statement) throws SQLException {\r\n        System.out.println(\"current statement to execute: \" +statement);\r\n\r\n        try (Statement stmt = getConnection.getConnection().createStatement()) {\r\n            // Execute the SQL statement\r\n            stmt.executeUpdate(statement);\r\n            //   ResultSet rs = stmt.executeQuery(statement);\r\n\r\n            // Get the attribute names\r\n//            ResultSetMetaData metaData = rs.getMetaData();\r\n//            int ccount = metaData.getColumnCount();\r\n//            for (int c = 1; c <= ccount; c++) {\r\n//                System.out.print(metaData.getColumnName(c) + \"\\t\");\r\n//            }\r\n//            System.out.println();\r\n////TODO: move the while loop in executeQuery, searchBookDB and this one to it´s own method\r\n//            // Get the attribute values\r\n//            while (rs.next()) {\r\n//\r\n//                int bookId = rs.getInt(\"book_id\");\r\n//                String ISBN = rs.getString(\"ISBN\");\r\n//                String title = rs.getString(\"title\");\r\n///*\r\n//                Author author = new Author();\r\n//                author.setfName(rs.getString(\"author\"));\r\n//*/\r\n//                String author = rs.getString(\"Author\");\r\n//                //String author = rs.getString(\"author\");\r\n//                Date published = rs.getDate(\"year\");\r\n//                //   int pages = rs.getInt(\"pages\");\r\n//                //  String language = rs.getString(\"language\");\r\n//                int genre_id = rs.getInt(\"genre_id\");\r\n//                int grade = rs.getInt(\"grade\");\r\n//                Book book = new Book(bookId, ISBN, title,author, published, genre_id, grade);\r\n//                System.out.println(book.toString());\r\n            //  books.add(book);\r\n\r\n            //  }\r\n\r\n            System.out.println(\"executed a statement\");\r\n        }catch (SQLException e){\r\n            System.err.println(\"FUCK! Something failed again! \"+ e.getMessage());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the grade for a book with the specified title.\r\n     *\r\n     * @param grade The new grade for the book.\r\n     * @param title The title of the book to update.\r\n     */\r\n    public static void updateGrade(int grade, String title) {\r\n        var sql = \"UPDATE T_book \"\r\n                + \"SET grade = ? \"\r\n                + \"WHERE title = ?\";\r\n    //    Connection conn = getConnection.getConnection();\r\n        try (var stmt = getConnection.getConnection().prepareStatement(sql)) {\r\n\r\n            // prepare data for update\r\n//            stmt.setString(1, title);\r\n//            stmt.setInt(2, grade);\r\n            stmt.setString(2, title);\r\n            stmt.setInt(1, grade);\r\n\r\n            // execute the update\r\n            int rowAffected = stmt.executeUpdate();\r\n            System.out.println(\"Row affected \" + rowAffected);\r\n        } catch (SQLException ex) {\r\n            System.err.println(ex.getMessage());\r\n        }\r\n    }\r\n\r\n    public static void addBook(String isbn, String title, String genre, String fullName) throws SQLException {\r\n        try(Statement stmt = getConnection.getConnection().createStatement()){\r\n            // Execute the SQL statement\r\n            ResultSet rs = stmt.executeQuery(\"SELECT MAX(book_id) AS currentBookID, MAX(aut_id) AS currentAuthorID\\n\" +\r\n                    \"FROM T_book\\n\" +\r\n                    \"LEFT JOIN T_author\\n\" +\r\n                    \"ON book_id = aut_id;;\");\r\n\r\n            ResultSetMetaData metaData = rs.getMetaData();\r\n            int ccount = metaData.getColumnCount();\r\n            for (int c = 1; c <= ccount; c++) {\r\n                System.out.print(metaData.getColumnName(c) + \"\\t\");\r\n            }\r\n            System.out.println();\r\n            rs.next();\r\n            int currentBook_id = rs.getInt(\"currentBookID\") + 1;\r\n            int currentAut_id = rs.getInt(\"currentAuthorID\") + 1;\r\n        System.out.println(\"bokID: \"+ currentBook_id +\"AutID: \" + currentAut_id);\r\n//            executeStatement(\"START TRANSACTION;\");\r\n            getConnection.getConnection().setAutoCommit(false);\r\n\r\n            if (!authorExists(fullName)) {\r\n                executeStatement(\"INSERT INTO T_Author (fullName) VALUES ( '\" + fullName + \"');\");\r\n                System.out.println(\"Author\" + fullName + \"added!\");\r\n            }\r\n            executeStatement(\"INSERT INTO T_book (isbn, title, genre) VALUES ('\" + isbn + \"' ,'\" + title + \"' ,'\" + genre + \" ' );\");\r\n        System.out.println(\"added\" + isbn +\",\"+ title+ \",\"+ genre + \"To book\");\r\n            //gör både lägg till T_book och lägg till book_id, aut_id i book_autho\r\n            executeStatement(\"INSERT INTO book_author (book_id, author_id) VALUES (\" + currentBook_id  + \",\"  + currentAut_id + \" );\");\r\n        System.out.println(\"wtf! This is incredible!\");\r\n\r\n            // Kontrollera om det finns några fel\r\n            int errorCount = getConnection.getConnection().getTransactionIsolation();\r\n       int realErrorCount = getErrorCount(\" SELECT @@error_count;\");\r\n        System.out.println(\"Real error count: \" + realErrorCount);\r\n        System.out.println(\"Dont know what error count this is?: \" + errorCount);\r\n\r\n            if (realErrorCount != 0) {\r\n                // Gör en rollback\r\n                getConnection.getConnection().rollback();\r\n                  getConnection.getConnection().setAutoCommit(true);\r\n            } else {\r\n                // Gör en commit\r\n                //getConnection.getConnection().commit();\r\n                executeStatement(\"commit;\");\r\n                  getConnection.getConnection().setAutoCommit(true);\r\n                System.out.println(\"Changes commited to database\");\r\n            }\r\n}catch(SQLException e){\r\n    System.out.println(\"Ett fel inträffade i addBook: \" + e.getMessage());\r\n}\r\n\r\n    }\r\n\r\n\r\n    //TODO: borde gå att köra denna med prepared statements om man redigerar den\r\n    // se SQL-statements i metoden ovan\r\n\r\n    /**\r\n     *\r\n     *\r\n     * */\r\n    public static void addBook1(String isbn, String title, String genre, String fullName) throws SQLException {\r\n        var sql2 = \"INSERT INTO T_book (isbn, title, genre) VALUES (?, ?, ?)\";\r\n        var sql1 = \"INSERT INTO T_Author (fullName) VALUES (?)\";\r\n        var sql3 = \"INSERT INTO book_author (book_id, author_id) VALUES ((SELECT book_id FROM t_book WHERE title = ' (?) ',(SELECT aut_id FROM t_author WHERE fullname = ' (?) '))\";\r\n        getConnection.getConnection().setAutoCommit(false); //TODO: lite osäker på om det är ok att sätta den här\r\n        if (!authorExists(fullName)) {\r\n\r\n            try (var stmt = getConnection.getConnection().prepareStatement(sql1)) {\r\n                // Skapa författaren\r\n                stmt.setString(1, fullName);\r\n                stmt.executeUpdate();\r\n                int rowAffected = stmt.executeUpdate();\r\n                System.out.println(\"Row affected \" + rowAffected);\r\n            } catch (SQLException ex) {\r\n                System.err.println(ex.getMessage());\r\n            }\r\n        }\r\n\r\n\r\n        //gör både lägg till T_book och lägg till book_id, aut_id i book_author\r\n    try(var stmt2 = getConnection.getConnection().prepareStatement(sql2);) {\r\n        // Lägg till boken\r\n        stmt2.setString(1, isbn);\r\n        stmt2.setString(2, title);\r\n        stmt2.setString(3, genre);\r\n        stmt2.executeUpdate();\r\n\r\n    }\r\n        try(var stmt3 = getConnection.getConnection().prepareStatement(sql3);) {\r\n            // Lägg till boken\r\n            stmt3.setString(1, isbn);\r\n            stmt3.setString(2, title);\r\n            stmt3.executeUpdate();\r\n        }\r\n\r\n    //lägg till book_id och aut_id i book_author\r\n//   var stmt3 = getConnection.getConnection().prepareStatement(sql3);\r\n//    stmt3.setString(1, title);\r\n//    stmt3.setString(2, fullName);\r\n//    stmt3.executeUpdate();\r\n//    int rowAffected = stmt2.executeUpdate();\r\n//    System.out.println(\"Row affected \" + rowAffected);\r\n\r\n    // Kontrollera om det finns några fel\r\n    int errorCount = getConnection.getConnection().getTransactionIsolation();\r\n    if (errorCount != 0) {\r\n        // Gör en rollback\r\n        getConnection.getConnection().rollback();\r\n        getConnection.getConnection().setAutoCommit(true);\r\n    } else {\r\n        // Gör en commit\r\n        getConnection.getConnection().commit();\r\n        getConnection.getConnection().setAutoCommit(true);\r\n    }\r\n\r\n//}catch(SQLException e){\r\n//    System.out.println(\"Ett fel inträffade i addBook: \" + e.getMessage());\r\n//}\r\n}\r\n    /**används för att kolla om en author existerar i T_book\r\n     * används av metoden addBookToDB\r\n     *\r\n     *\r\n     * */\r\npublic static boolean authorExists(String author){\r\n        //TODO: använd en author här istället för en String?\r\n    String query = \"SELECT COUNT(*) FROM T_author WHERE fullName ='\" + author + \"'\";\r\n    Connection con = getConnection.getConnection();\r\n    try (Statement stmt = con.createStatement()) {\r\n        // Execute the SQL statement\r\n        ResultSet rs = stmt.executeQuery(query);\r\n        rs.next();\r\n        int count = rs.getInt(1);\r\n        if (count > 0){\r\n            System.out.println(author + \" exists in DB!\");\r\n            return true;\r\n        }\r\n    } catch (SQLException e) {\r\n        System.err.println(e.getMessage());\r\n    }\r\n   System.out.println(author + \" does not exist in DB!\");\r\n    return false;\r\n}\r\n\r\n\r\n\r\n//TODO: spara tills vidare, försök att använda ett preparedStatement,\r\n// vilket ska förhindra SQL-injection\r\n    public static boolean checkIfAuthorExist(String author) {\r\n        var sql = \"SELECT * FROM T_book WHERE author = ?\";\r\n\r\n\r\n            // prepare data for update\r\n//            stmt.setString(1, title);\r\n//            stmt.setInt(2, grade);\r\n\r\n        try (var con = getConnection.getConnection();\r\n             var stmt = con.prepareStatement(sql)) {\r\n            stmt.setString(1, author);\r\n            // Execute the SQL statement\r\n            ResultSet rs = stmt.executeQuery(sql);\r\n            rs.next();\r\n            int count = rs.getInt(1);\r\n            if (count > 0){\r\n                System.out.println(author + \" exists in DB!\");\r\n                return true;\r\n            }\r\n        } catch (SQLException e) {\r\n            System.err.println(e.getMessage());\r\n        }\r\n        System.out.println(author + \" does not exist in DB!\");\r\n        return false;\r\n\r\n    }\r\n\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/dblab1/dblab1_jdbc/model/BooksDb.java b/src/main/java/dblab1/dblab1_jdbc/model/BooksDb.java
--- a/src/main/java/dblab1/dblab1_jdbc/model/BooksDb.java	(revision d0f6f54f279276cb3e83375b4e23cb6636ce3db6)
+++ b/src/main/java/dblab1/dblab1_jdbc/model/BooksDb.java	(date 1705245141075)
@@ -319,11 +319,10 @@
                   getConnection.getConnection().setAutoCommit(true);
                 System.out.println("Changes commited to database");
             }
-}catch(SQLException e){
+    }catch(SQLException e){
     System.out.println("Ett fel inträffade i addBook: " + e.getMessage());
-}
-
-    }
+    }
+}
 
 
     //TODO: borde gå att köra denna med prepared statements om man redigerar den
